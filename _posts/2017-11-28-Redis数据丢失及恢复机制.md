---
layout: post
title: Redis数据丢失及恢复机制
date: 2017-11-28
categories: blog
tags: [redis]
description: Redis数据丢失及恢复机制
---
# Redis数据回写机制

Redis的数据回写机制分同步和异步两种，
1.同步回写即SAVE命令，主进程直接向磁盘回写数据。在数据大的情况下会导致系统假死很长时间，所以一般不是推荐的。

2.异步回写即BGSAVE命令，主进程fork后，复制自身并通过这个新的进程回写磁盘，回写结束后新进程自行关闭。由于这样做不需要主进程阻塞，系统不会假死，一般默认会采用这个方法。

内存中的热数据随时可能修改，要在磁盘上保存某个时间的内存镜像必须要冻结。冻结就会导致假死。fork一个新的进程之后等于复制了当时的一个内存镜像，这样主进程上就不需要冻结，只要子进程上操作就可以了。
在小内存的进程上做一个fork,不需要太多资源，但当这个进程的内存空间以Ｇ为单位时，很大可能会报内存无法分配的。越是改动频繁的主机上fork也越频繁，fork操作本身的代价恐怕也不会比假死好多少。

# Redis持久化配置

目前Redis持久化的方式有两种： RDB 和 AOF

## RDB机制

RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘。 也是默认的持久化方式，这种方式是就是将内存中数据以快照的方式写入到二进制文件中,默认的文件名为dump.rdb

在redis.conf中已经有了如下配置:

	save 900 1		#900秒内如果超过1个key被修改，则发起快照保存
	save 300 10		#300秒内如果超过10个key被修改，则发起快照保存
	save 60 10000	#60秒内如果超过1个key被修改，则发起快照保存

### RDB保存文件的过程

> redis调用fork,现在有了子进程和父进程。
> 父进程继续处理client请求，子进程负责将内存内容写入到临时文件。由于os的写时复制机制（copy on write)父子进程会共享相同的物理页面，当父进程处理写请求时os会为父进程要修改的页面创建副本，而不是写共享的页面。所以子进程的地址空间内的数 据是fork时刻整个数据库的一个快照。
> 当子进程将快照写入临时文件完毕后，用临时文件替换原来的快照文件，然后子进程退出。

### RDB优势

> 整个Redis数据库将只包含一个文件，这样非常方便进行备份。很容易的将一个RDB文件移动到其他的存储介质上
> RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。
> RDB 可以最大化 Redis 的性能：父进程在保存 RDB 文件时唯一要做的就是 fork 出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘 I/O 操作。

### RDB劣势

> 因为RDB 文件需要保存整个数据集的状态,所以它并不是一个轻松的操作。 因此你可能会至少 5 分钟才保存一次 RDB 文件。 在这种情况下， 一旦发生故障停机， 你就可能会丢失好几分钟的数据
> 每次保存 RDB 的时候，Redis 都要 fork() 出一个子进程，并由子进程来进行实际的持久化工作。 在数据集比较庞大时， fork() 可能会非常耗时.虽然 AOF 重写也需要进行 fork() ，但无论 AOF 重写的执行间隔有多长，数据的耐久性都不会有任何损失。

## AOF机制

AOF是AppendOnly File的缩写，是Redis系统提供了一种记录Redis操作的持久化方案，在AOF生成的文件中，将忠实记录发生在Redis的操作，从而达到在Redis服务器重启或者当机之后，继续恢复之前数据状态的机制。

在redis.conf中配置即可

	appendonly yes              //启用aof持久化方式
	# appendfsync always      //每次收到写命令就立即强制写入磁盘，最慢的，但是保证完全的持久化，不推荐使用
	appendfsync everysec     //每秒钟强制写入磁盘一次，在性能和持久化方面做了很好的折中，推荐
	# appendfsync no    	//完全依赖os，性能最好,持久化没保证

		
### AOF保存文件过程
		
> redis调用fork ，现在有父子两个进程
> 子进程根据内存中的数据库快照，往临时文件中写入重建数据库状态的命令
> 父进程继续处理client请求，除了把写命令写入到原来的aof文件中。同时把收到的写命令缓存起来。这样就能保证如果子进程重写失败的话并不会出问题。
> 当子进程把快照内容写入已命令方式写到临时文件中后，子进程发信号通知父进程。然后父进程把缓存的写命令也写入到临时文件。
> 现在父进程可以使用临时文件替换老的aof文件，并重命名，后面收到的写命令也开始往新的aof文件中追加。
	
### AOF优势

> 使用 AOF 持久化会让 Redis 变得非常耐久（much more durable）：你可以设置不同的 fsync 策略，比如无 fsync ，每秒钟一次 fsync ，或者每次执行写入命令时 fsync 。 AOF 的默认策略为每秒钟 fsync 一次，在这种配置下，Redis 仍然可以保持良好的性能，并且就算发生故障停机，也最多只会丢失一秒钟的数据
> Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写
> AOF 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 Redis 协议的格式保存， 因此 AOF 文件的内容非常容易被人读懂， 对文件进行分析（parse）也很轻松

### AOF劣势

> 对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。

# 选择
到底选择什么呢？下面是来自官方的建议：
通常，如果你要想提供很高的数据保障性，那么建议你同时使用两种持久化方式。
如果你可以接受灾难带来的几分钟的数据丢失，那么你可以仅使用RDB。
很多用户仅使用了AOF，但是我们建议，既然RDB可以时不时的给数据做个完整的快照，并且提供更快的重启，所以最好还是也使用RDB。
因此，我们希望可以在未来（长远计划）统一AOF和RDB成一种持久化模式。

# The End




Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。

redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。

# Redis安装

## 1.1 redis下载

	[root@instance-5tiad5rl ~]# wget http://download.redis.io/releases/redis-3.0.5.tar.gz
	
## 1.2 redis解压

	[root@instance-5tiad5rl ~]# tar xf redis-3.0.5.tar.gz

这样就在当前目录下新建了一个包含发行版源代码的目录，必须cd进入这个目录以继续服务器的编译。

## 1.3 编译及安装

	[root@instance-5tiad5rl ~]# make
	[root@instance-5tiad5rl ~]# make install
	
这时会把这些可执行程序拷贝到/usr/local/bin目录下，由于/usr/local/bin是在系统的环境变量$PATH下定义的，因此终端在任意位置就可以执行redis-server和redis-cli了。

至此redis安装就已初步完成,我们可以看下/usr/local/bin/下几个程序分别是做什么的,这里只做一个简单记录。

redis-server：即我们的redis服务,最重要的一个服务

redis-cli：redis client，提供一个redis客户端，以供连接到redis服务，进行增删改查等操作

redis-sentinel：redis实例的监控管理、通知和实例失效备援服务

redis-benchmark：redis的性能测试工具

redis-check-aof：若以AOF方式的持久化，当意外发生时用来快速修复

redis-check-rdb：若以RDB方式的持久化，当意外发生时用来快速修复

## 1.4 移动配置文件

文件放在固定目录便于管理,也可以不这么做,不过建议自己管理一下命令和配置,文件路径如下:

配置文件: vi /etc/redis/redis.conf
dump file、进程pid、log目录等，一般放在/var/redis/

<img src="http://ozupw8iis.bkt.clouddn.com/201711283.png" align="center" class="img-responsive">

## 1.5 redis启动及关闭
	
安装完成后,启动redis-server,并运行redis-cli进行连接测试:

	[root@instance-5tiad5rl ~]# redis-server /etc/redis/redis.conf
	[root@instance-5tiad5rl ~]# redis-cli

<img src="http://ozupw8iis.bkt.clouddn.com/201711281.png" align="center" class="img-responsive">

随便往里面插入一个值测试一下，可以正常获取，说明客户端没有问题。退出客户端的话直接quit即可。

<img src="http://ozupw8iis.bkt.clouddn.com/201711282.png" align="center" class="img-responsive">

关闭redis可以使用如下命令

	[root@instance-5tiad5rl ~]# pkill redis-server
	
或
	
	[root@instance-5tiad5rl ~]# redis-cli shutdown

可使用命令查看进程是否存在

	[root@instance-5tiad5rl ~]# ps -ef | grep redis

<br />

# redis配置

## 2.1 redis.conf配置

	vi /etc/redis/redis.conf 

查找daemonize no改为  

	daemonize yes  
	
以守护进程方式运行 

修改dir ./为绝对路径,默认的话redis-server启动时会在当前目录生成或读取dump.rdb,所以如果在根目录下执行redis-server /etc/redis.conf的话,读取的是根目录下的dump.rdb,为了使redis-server可在任意目录下执行:

	dir /var/redis

指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。
修改appendonly为yes 

为了让redis-server能在系统启动时自动运行，需要将redis服务作为守护进程（daemon）来运行，我们回到/etc/redis/目录中找到一个redis.conf的文件，这个文件是redis服务运行时加载的配置，我们先观察一下其中的内容

此文件内容非常长，但是大部分是注释，我们重点关注其中的几个设置daemonize和pidfile：

其中daemonize默认值是false，pidfile默认值是pidfile /var/run/redis_6379.pid

第一个表示是否daemon化，显然我们要把它改成daemonize yes；

第二个表示当服务以守护进程方式运行时，redis默认会把pid写入/var/run/redis_6379.pid文件，服务运行中该文件就存在，服务一旦停止该文件就自动删除，因而可以用来判断redis是否正在运行。

保存后退出。

## 2.2 redis_init_script设置
redis源码里其实已经提供了一个初始化脚本，用来管理启动、关闭、重启,位置在安装目录下,我的在/data/redis-3.0.5/utils/redis_init_script

<img src="http://ozupw8iis.bkt.clouddn.com/201711284.png" align="center" class="img-responsive">

脚本中指定了端口、server路径、cli路径、pidfile路径以及conf路径，上述标注的地方都需要正确配置，多说一句，如果在安装时执行了make install，那么这里的脚本不需要做多大改动，因为make install把server和cli都拷到/usr/local/bin下面了。

另外看到这里conf的路径，我们需要把redis目录下的redis.conf文件拷贝到/etc/redis/6379.conf

<img src="http://ozupw8iis.bkt.clouddn.com/201711285.png" align="center" class="img-responsive">

我这里之前已经放了一个redis.conf,不影响

接着将redis_init_script脚本拷贝到/etc/init.d/redisd

	[root@instance-5tiad5rl redis]# cp /baidudata/redis-3.0.5/utils/redis_init_script /etc/init.d/redisd

在/etc/init.d下的脚本都是可以在系统启动是自动启动的服务，而现在还缺一个系统启动时的配置：

	[root@instance-5tiad5rl redis]# chkconfig redisd on

发现报错如下:

<img src="http://ozupw8iis.bkt.clouddn.com/201711286.png" align="center" class="img-responsive">

解决办法是在redis_init_script的开头加如下配置:

	#!/bin/sh
	# chkconfig: 2345 90 10 
	# description: Redis is a persistent key-value database

上面的注释的意思是，redis服务必须在运行级2，3，4，5下被启动或关闭，启动的优先级是90，关闭的优先级是10。

保存完重新拷贝到/etc/init.d/redisd后，再运行chkconfig就完成了。

<img src="http://ozupw8iis.bkt.clouddn.com/201711287.png" align="center" class="img-responsive">

一切就绪之后，可以执行以下命令检验service是否设置成功:

	[root@instance-5tiad5rl redis]# service redisd start
	[root@instance-5tiad5rl redis]# service redisd stop

如下:

<img src="http://ozupw8iis.bkt.clouddn.com/201711288.png" align="center" class="img-responsive">

最后重启一下系统吧，进入系统之后直接运行redis-cli检验redis服务是否已经自动运行了。

## 2.3 配置redis外网可访问

redis默认只允许本地访问，要使redis可以远程访问可以修改redis.conf

### 2.3.1 开放redis端口

关闭防火墙

	[root@instance-5tiad5rl redis]# service iptables stop 

进入iptables

	[root@instance-5tiad5rl redis]# vi /etc/sysconfig/iptables

添加信任端口

	-A INPUT -m state --state NEW -m tcp -p tcp --dport 6379 -j ACCEPT

重启防火墙

	[root@instance-5tiad5rl redis]# service iptables restart 
	
### 2.3.2 修改redis.conf文件

将所有bind注释

	# bind 192.168.1.100 10.0.0.1
	# bind 127.0.0.1 ::1
	
重启redis服务即可。

## 2.4 redis设置密码
出于安全考虑,我设置了redis的密码,具体步骤如下

不论是/etc/redis/redis.conf ,还是/etc/redis/6379.conf都一样,这里以redis.conf为例

	vi /etc/redis/redis.conf 
	
找到#requirepass foobared  

去掉行前的注释，并修改密码为所需的密码,保存文件

	requirepass 123456

使用我们之前的命令重启redis,如下所示,最开始的不输入密码登录redis-cli,提示没有权限,-a后面就是刚刚设置的密码

<img src="http://ozupw8iis.bkt.clouddn.com/201711289.png" align="center" class="img-responsive">

另外一种设置密码的方法就是登入redis-cli,使用如下set密码即可,这种方法无需重启redis

<img src="http://ozupw8iis.bkt.clouddn.com/2017112810.png" align="center" class="img-responsive">

# 总结

之前一直用redis服务器和关于java的API,这次借着新部署服务器的机会,从头体验了下redis的安装和配置,以上配置结束,基本就满足个人的测试和使用了。

# The End